package com.practice.securewifi.check.password_generation

import com.practice.securewifi.data.password_lists.entity.PersonInfo
import com.practice.securewifi.data.password_lists.entity.PlaceName
import kotlin.random.Random

class DynamicPasswordsGenerator(
    private val passwordGeneratorFromPersonInfo: PasswordGeneratorFromPersonInfo,
    private val passwordGeneratorFromPlaceName: PasswordGeneratorFromPlaceName,
    private val passwordGeneratorFromSsid: PasswordGeneratorFromSsid
) {

    fun generatePasswordsForGivenInfo(
        ssid: String,
        amountOfGeneratedPasswords: Int,
        personInfoList: List<PersonInfo>,
        placesNames: List<PlaceName>
    ): List<String> {
        val ssidTerm = if (ssid.isNotEmpty()) 1 else 0
        val personInfoTerm = if (personInfoList.isNotEmpty()) 1 else 0
        val placesNamesTerm = if (placesNames.isNotEmpty()) 1 else 0
        val providedInfoSources = ssidTerm + personInfoTerm + placesNamesTerm
        if (providedInfoSources == 0 // no info == no generated passwords
            || amountOfGeneratedPasswords == 0 // or amount of generated passwords is zero == no generated passwords
        ) return emptyList()
        val allGeneratedPasswords: MutableList<String> = mutableListOf()
        val passwordsForEveryInfo = splitNumber(amountOfGeneratedPasswords, providedInfoSources)
        passwordsForEveryInfo.forEachIndexed { index, passwordAmount ->
            when (index) {
                0 -> {
                    if (personInfoList.isNotEmpty()) {
                        allGeneratedPasswords += generatePasswordsFromAllPersonInfo(
                            personInfoList,
                            passwordAmount
                        )
                    }
                }

                1 -> {
                    if (placesNames.isNotEmpty()) {
                        allGeneratedPasswords += generatePasswordsFromPlaceNames(
                            placesNames,
                            passwordAmount
                        )
                    }
                }

                2 -> {
                    if (ssid.isNotEmpty()) {
                        allGeneratedPasswords += passwordGeneratorFromSsid.generatePasswordsFromSsid(
                            ssid,
                            passwordAmount
                        )
                    }
                }
            }
        }

        // since amount of passwords generated by each generation function is not guaranteed
        // to be exact passwordsAmount, we need to fill remaining spots with other passwords
        // since exact amount of passwords is expected to be returned by this function
        if (allGeneratedPasswords.size < amountOfGeneratedPasswords) {
            val restOfPasswords = generateRestOfPasswords(amountOfGeneratedPasswords - allGeneratedPasswords.size)
            allGeneratedPasswords += restOfPasswords
        }

        return allGeneratedPasswords
    }

    private fun generatePasswordsFromAllPersonInfo(
        personInfo: List<PersonInfo>,
        passwordsAmount: Int
    ): List<String> {
        val passwordsAmtForEveryInfo = splitNumber(passwordsAmount, personInfo.size)
        passwordsAmtForEveryInfo.forEachIndexed { index, passwordsAmt ->
            passwordGeneratorFromPersonInfo.generatePasswordsFromPersonInfo(
                personInfo = personInfo[index],
                passwordsAmount = passwordsAmt
            )
        }
        return emptyList()
    }

    private fun generatePasswordsFromPlaceNames(
        placesNames: List<PlaceName>,
        passwordsAmount: Int
    ): List<String> {
        val passwordsAmtForEveryPlaceName = splitNumber(passwordsAmount, placesNames.size)
        passwordsAmtForEveryPlaceName.forEachIndexed { index, passwordsAmt ->
            passwordGeneratorFromPlaceName.generatePasswordsFromPlaceName(
                placeName = placesNames[index],
                passwordsAmount = passwordsAmt
            )
        }
        return emptyList()
    }

    private fun generateRestOfPasswords(amount: Int): List<String> {
        var generatedPasswords: MutableList<String> = mutableListOf()
        val popularNumberPasswords = listOf(
            "00000000",
            "11111111",
            "22222222",
            "33333333",
            "44444444",
            "55555555",
            "66666666",
            "77777777",
            "88888888",
            "99999999",
            "12345678",
            "123456789",
            "87654321",
            "13579246",
            "135792468",
            "69696969"
        )
        val popularPasswords = listOf("qwertyui", "asdfghjk", "Qwertyui")
        generatedPasswords += popularNumberPasswords + popularPasswords
        if (generatedPasswords.size >= amount) {
            return generatedPasswords.subList(0, amount)
        }

        repeat(amount - generatedPasswords.size) {
            val randomNumber = Random.nextInt(0, 100_000_000)
            val randomNumberString = String.format("%08d", randomNumber)
            generatedPasswords.add(randomNumberString)
        }

        generatedPasswords = generatedPasswords.distinct().toMutableList()
        // generate what's left to be generated after making list distinct
        // (generate for amount of duplicates, which are unlikely)
        while (generatedPasswords.size < amount) {
            val randomNumber = Random.nextInt(0, 100_000_000)
            val randomNumberString = String.format("%08d", randomNumber)
            if (!generatedPasswords.contains(randomNumberString)) {
                generatedPasswords.add(randomNumberString)
            }
        }

        return generatedPasswords
    }

    // returns list of size [parts]
    // each item in the list corresponds to the amount given to the part
    private fun splitNumber(number: Int, parts: Int): List<Int> {
        val remainder = number % parts
        val base = number / parts
        val result = mutableListOf<Int>()

        for (i in 0 until parts) {
            result.add(base)
        }

        // Distribute the remainder evenly
        for (i in 0 until remainder) {
            result[i]++
        }

        return result
    }
}